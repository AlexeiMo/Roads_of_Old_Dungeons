# Содержание
1. [Проектирование архитектуры](#part1)  
1.1. [Тип приложения](#type_app)  
1.2. [Стратегия развертывания](#strategy)   
1.3. [Выбор технологии](#technology)  
1.4. [Показатели качества](#quality_indicator)  
1.5. [Пути реализации сквозной функциональности](#way_implimintation)   
1.6. [Архитектура "To be"](#to_be)  
2. [Анализ архитектуры](#part2)      
2.1. [Архитектура "As is"](#as_is)
3. [Сравнениие и рефакторинг](#part3)   
3.1. [Сравнение архитектуры «As is» и «To be»](#compare)  
3.2. [Анализ](#analysis)   
3.3. [Пути улучшения архитектуры](#way_upgrade)  


<a name="part1"/>

# Проектирование архитектуры

<a name="type_app"/>

## 1.	Тип приложения
Насыщенное клиентское приложение.

<a name="strategy"/>

## 2.	Стратегия развёртывания 
Нераспределенное развертывание по схеме "Клиент-сервер".

<a name="technology"/>

## 3. Выбор технологии
  - C# - современный объектно-ориентированный и 
  типобезопасный язык программирования. C# относится к широко известному семейству 
  языков C, и покажется хорошо знакомым любому, кто работал с C, C++, Java или JavaScript.
  - Unity - межплатформенная среда разработки компьютерных игр, разработанная американской
  компанией Unity Technologies. Unity позволяет создавать приложения, работающие на более
  чем 25 различных платформах, включающих персональные компьютеры, игровые консоли, мобильные
  устройства, интернет-приложения и другие.

<a name="quality_indicator"/>

## 4. Показатели качества
  - Концептуальная целостность
  - Удобство и простота использования
  - Возможность повторного использования
  
  <a name="way_implimintation"/>
  
## 5.  Пути реализации сквозной функциональности: 
  - Управление конфигурацией: распределить элементы конфигурации по логическим разделам на основании
  того, являются ли они настройками пользователя, приложения или среды.
  - Управление состоянием: обеспечить сериализуемость данных для надёжного хранения и возможномсти
  отправки на другой компьютер.
  - Управление исключениями: обеспечить, чтобы приложение не оставлось в нестабильном состоянии после сбоя.
  
  <a name="to_be"/>
  
 ## "To be" архитектура:
 1. Диаграмма компонентов.        
 ![](https://github.com/RuslanGitelman/Roads_of_Old_Dungeons/blob/master/Diagram/ComponentDiagramToBe.png)
 2. Диаграмма развертывания.      
 ![](https://github.com/RuslanGitelman/Roads_of_Old_Dungeons/blob/master/Diagram/DeploymentDiagramToBe.png)
  
 <a name="part2"/>
 
 # Часть 2
 
 <a name="as_is"/>
 
 ## "As is" архитектура:
 1. Диаграмма компонентов.
 ![](https://github.com/RuslanGitelman/Roads_of_Old_Dungeons/blob/master/Diagram/ActualComponents.jpg)
 2. Диаграмма развертывания.
 ![](https://github.com/RuslanGitelman/Roads_of_Old_Dungeons/blob/master/Diagram/ActualDeployment.jpg)
 3. Диаграмма классов
 ![](https://github.com/RuslanGitelman/Roads_of_Old_Dungeons/blob/master/Diagram/ActualClassDiagramm.jpg)
 
 <a name="part3"/>
 
 # Часть 3
 
  <a name="compare"/>
  
**1.** В процессе разработки 1-го спринта мы определили, что для реализации определённой функциональности
нашего приложения в дальнейшем понадобится система для хранения и последующего использования данных.
Для её решения наша команда решила использовать реляционные базы данных, что в перспективе обеспечит высокую эффективность и производительность нашего приложения.

 <a name="analysis"/>
 
**2.** Проанализировав архитектуры "As is" и "To be" , наша команда сделала вывод, что обязательно требуется реализовать доступ, хранение и получение данных с помощью реляционных баз данных.

 <a name="way_upgrade"/>
 
**3.** В связи с вышеперечисленными причинами и опытом, полученным в процессе разработки в течение 1 спринта, мы будет улучшать архитектуру согласно следующим принципам:

- принцип единственности ответственности;
- принцип минимального знания;
- принцип DRY(Don't Repeat Yourself).
